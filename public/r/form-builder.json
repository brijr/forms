{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-builder",
  "type": "registry:block",
  "title": "Form Builder",
  "description": "A complete form builder component with drag-and-drop field management, validation, and form rendering capabilities.",
  "dependencies": [
    "@dnd-kit/core@^6.3.1",
    "@dnd-kit/sortable@^10.0.0",
    "@dnd-kit/utilities@^3.2.2",
    "@tanstack/react-form@^1.25.0",
    "@tanstack/zod-form-adapter@^0.42.1",
    "zod@^4.1.12",
    "sonner@^2.0.7",
    "lucide-react@^0.554.0",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "inline-edit",
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "radio-group",
    "switch",
    "slider",
    "field",
    "dialog",
    "tooltip",
    "label",
    "dropdown-menu",
    "sidebar"
  ],
  "files": [
    {
      "path": "registry/new-york/forms/lib/form-config.ts",
      "content": "import {\n  TypeIcon,\n  MailIcon,\n  PhoneIcon,\n  HashIcon,\n  AlignLeftIcon,\n  ChevronDownCircleIcon,\n  CheckSquareIcon,\n  CircleDotIcon,\n  SquareCheckIcon,\n  ToggleRightIcon,\n  SlidersHorizontalIcon,\n  LucideIcon,\n} from \"lucide-react\";\n\n// Field types supported by the form builder\nexport type FieldType =\n  | \"text\"\n  | \"email\"\n  | \"phone\"\n  | \"number\"\n  | \"textarea\"\n  | \"select\"\n  | \"checkbox\"\n  | \"checkbox-group\"\n  | \"radio\"\n  | \"yes-no\"\n  | \"switch\"\n  | \"slider\"\n\n// Validation rules that can be applied to fields\nexport interface ValidationRule {\n  required?: boolean\n  minLength?: number\n  maxLength?: number\n  min?: number\n  max?: number\n  pattern?: string\n  email?: boolean\n  custom?: string // Custom validation message\n}\n\n// Option for select, radio, and checkbox groups\nexport interface FieldOption {\n  label: string\n  value: string\n}\n\n// Base field configuration\nexport interface BaseFieldConfig {\n  id: string\n  type: FieldType\n  name: string\n  label: string\n  placeholder?: string\n  description?: string\n  defaultValue?: string | number | boolean | string[]\n  validation?: ValidationRule\n}\n\n// Text field specific config\nexport interface TextFieldConfig extends BaseFieldConfig {\n  type: \"text\" | \"email\" | \"phone\"\n}\n\n// Number field specific config\nexport interface NumberFieldConfig extends BaseFieldConfig {\n  type: \"number\"\n  defaultValue?: number\n}\n\n// Textarea field specific config\nexport interface TextareaFieldConfig extends BaseFieldConfig {\n  type: \"textarea\"\n  rows?: number\n}\n\n// Select field specific config\nexport interface SelectFieldConfig extends BaseFieldConfig {\n  type: \"select\"\n  options: FieldOption[]\n}\n\n// Checkbox group specific config\nexport interface CheckboxGroupFieldConfig extends BaseFieldConfig {\n  type: \"checkbox-group\"\n  options: FieldOption[]\n  defaultValue?: string[]\n}\n\n// Radio field specific config\nexport interface RadioFieldConfig extends BaseFieldConfig {\n  type: \"radio\"\n  options: FieldOption[]\n}\n\n// Checkbox field specific config\nexport interface CheckboxFieldConfig extends BaseFieldConfig {\n  type: \"checkbox\"\n  defaultValue?: boolean\n}\n\n// Switch field specific config\nexport interface SwitchFieldConfig extends BaseFieldConfig {\n  type: \"switch\"\n  defaultValue?: boolean\n}\n\n// Slider field specific config\nexport interface SliderFieldConfig extends BaseFieldConfig {\n  type: \"slider\"\n  min?: number\n  max?: number\n  step?: number\n  defaultValue?: number\n}\n\n// Yes/No field specific config\nexport interface YesNoFieldConfig extends BaseFieldConfig {\n  type: \"yes-no\"\n  defaultValue?: boolean\n}\n\n// Union type for all field configurations\nexport type FieldConfig =\n  | TextFieldConfig\n  | NumberFieldConfig\n  | TextareaFieldConfig\n  | SelectFieldConfig\n  | CheckboxGroupFieldConfig\n  | RadioFieldConfig\n  | CheckboxFieldConfig\n  | YesNoFieldConfig\n  | SwitchFieldConfig\n  | SliderFieldConfig\n\n// Form configuration\nexport interface FormConfig {\n  id: string\n  title: string\n  description?: string\n  fields: FieldConfig[]\n}\n\n// Helper function to create a new field with defaults\nexport function createDefaultField(type: FieldType, index: number): FieldConfig {\n  const baseId = `field_${Date.now()}_${index}`\n  const baseName = `field_${index}`\n\n  const baseConfig = {\n    id: baseId,\n    name: baseName,\n    label: `Field ${index + 1}`,\n    placeholder: \"\",\n    description: \"\",\n  }\n\n  switch (type) {\n    case \"text\":\n      return {\n        ...baseConfig,\n        label: \"Text\",\n        placeholder: \"Enter text...\",\n        type: \"text\",\n        defaultValue: \"\",\n      }\n    case \"email\":\n      return {\n        ...baseConfig,\n        id: baseId,\n        name: \"email\",\n        label: \"Email\",\n        type: \"email\",\n        defaultValue: \"\",\n        validation: { email: true },\n      }\n    case \"phone\":\n      return {\n        ...baseConfig,\n        id: baseId,\n        name: \"phone\",\n        label: \"Phone Number\",\n        type: \"phone\",\n        defaultValue: \"\",\n        validation: {\n          pattern: \"^[\\\\+]?[0-9]{7,15}$\",\n          custom: \"Enter a valid phone number.\"\n        },\n      }\n    case \"number\":\n      return {\n        ...baseConfig,\n        label: \"Number\",\n        placeholder: \"Enter a number...\",\n        type: \"number\",\n        defaultValue: undefined,\n      }\n    case \"textarea\":\n      return {\n        ...baseConfig,\n        label: \"Message\",\n        placeholder: \"Enter your message...\",\n        type: \"textarea\",\n        rows: 4,\n        defaultValue: \"\",\n      }\n    case \"select\":\n      return {\n        ...baseConfig,\n        label: \"Select\",\n        type: \"select\",\n        options: [\n          { label: \"First option\", value: \"first\" },\n          { label: \"Second option\", value: \"second\" },\n        ],\n        defaultValue: \"\",\n      }\n    case \"checkbox-group\":\n      return {\n        ...baseConfig,\n        label: \"Select all that apply\",\n        type: \"checkbox-group\",\n        options: [\n          { label: \"First option\", value: \"first\" },\n          { label: \"Second option\", value: \"second\" },\n        ],\n        defaultValue: [],\n      }\n    case \"radio\":\n      return {\n        ...baseConfig,\n        label: \"Choose one\",\n        type: \"radio\",\n        options: [\n          { label: \"First option\", value: \"first\" },\n          { label: \"Second option\", value: \"second\" },\n        ],\n        defaultValue: \"\",\n      }\n    case \"checkbox\":\n      return {\n        ...baseConfig,\n        label: \"I agree\",\n        type: \"checkbox\",\n        defaultValue: false,\n      }\n    case \"yes-no\":\n      return {\n        ...baseConfig,\n        label: \"Yes or No\",\n        type: \"yes-no\",\n        defaultValue: undefined,\n      }\n    case \"switch\":\n      return {\n        ...baseConfig,\n        label: \"Enable\",\n        type: \"switch\",\n        defaultValue: false,\n      }\n    case \"slider\":\n      return {\n        ...baseConfig,\n        label: \"Range\",\n        type: \"slider\",\n        min: 0,\n        max: 100,\n        step: 1,\n        defaultValue: 50,\n      }\n    default:\n      return {\n        ...baseConfig,\n        type: \"text\",\n        defaultValue: \"\",\n      }\n  }\n}\n\n// Helper function to create an empty form\nexport function createEmptyForm(): FormConfig {\n  return {\n    id: `form_${Date.now()}`,\n    title: \"\",\n    description: \"\",\n    fields: [],\n  }\n}\n\n// Field type configuration for the toolbox\nexport interface FieldTypeConfig {\n  type: FieldType;\n  label: string;\n  icon: LucideIcon;\n  category: \"basic\" | \"choice\";\n}\n\nexport const FIELD_TYPES: FieldTypeConfig[] = [\n  { type: \"text\", label: \"Text\", icon: TypeIcon, category: \"basic\" },\n  { type: \"email\", label: \"Email\", icon: MailIcon, category: \"basic\" },\n  { type: \"phone\", label: \"Phone\", icon: PhoneIcon, category: \"basic\" },\n  { type: \"number\", label: \"Number\", icon: HashIcon, category: \"basic\" },\n  { type: \"textarea\", label: \"Textarea\", icon: AlignLeftIcon, category: \"basic\" },\n  { type: \"select\", label: \"Select\", icon: ChevronDownCircleIcon, category: \"choice\" },\n  { type: \"radio\", label: \"Radio\", icon: CircleDotIcon, category: \"choice\" },\n  { type: \"yes-no\", label: \"Yes/No\", icon: CircleDotIcon, category: \"choice\" },\n  { type: \"checkbox-group\", label: \"Checkboxes\", icon: CheckSquareIcon, category: \"choice\" },\n  { type: \"checkbox\", label: \"Checkbox\", icon: SquareCheckIcon, category: \"choice\" },\n  { type: \"switch\", label: \"Switch\", icon: ToggleRightIcon, category: \"choice\" },\n  { type: \"slider\", label: \"Slider\", icon: SlidersHorizontalIcon, category: \"choice\" },\n];\n\nexport const CATEGORIES = [\n  { id: \"basic\", label: \"Basic Fields\" },\n  { id: \"choice\", label: \"Selection & Choice\" },\n] as const;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/forms/lib/form-utils.ts",
      "content": "import { z } from \"zod\";\nimport type { FieldConfig, FormConfig, ValidationRule, FieldType } from \"./form-config\";\nimport {\n  Type,\n  Mail,\n  Phone,\n  Hash,\n  AlignLeft,\n  ChevronDownCircle,\n  CheckSquare,\n  CircleDot,\n  SquareCheck,\n  ToggleRight,\n  SlidersHorizontal,\n  LucideIcon,\n} from \"lucide-react\";\n\n/**\n * Generates a Zod schema for a single field based on its configuration\n */\nexport function generateFieldSchema(field: FieldConfig): z.ZodTypeAny {\n  let schema: z.ZodTypeAny;\n\n  // Base schema based on field type\n  switch (field.type) {\n    case \"text\":\n    case \"email\":\n    case \"phone\":\n    case \"textarea\":\n      schema = z.string();\n      break;\n\n    case \"number\":\n      schema = z.number();\n      break;\n\n    case \"select\":\n    case \"radio\":\n      // Create union of valid option values\n      const options = field.options.map((opt) => opt.value);\n      if (options.length > 0) {\n        schema = z.enum(options as [string, ...string[]]);\n      } else {\n        schema = z.string();\n      }\n      break;\n\n    case \"checkbox-group\":\n      schema = z.array(z.string());\n      break;\n\n    case \"checkbox\":\n    case \"yes-no\":\n    case \"switch\":\n      schema = z.boolean();\n      break;\n\n    case \"slider\":\n      schema = z.number();\n      break;\n\n    default:\n      schema = z.string();\n  }\n\n  // Apply validation rules\n  if (field.validation) {\n    schema = applyValidationRules(schema, field.validation);\n  }\n\n  return schema;\n}\n\n/**\n * Applies validation rules to a Zod schema\n */\nfunction applyValidationRules(\n  schema: z.ZodTypeAny,\n  validation: ValidationRule\n): z.ZodTypeAny {\n  let result = schema;\n\n  // String validations\n  if (result instanceof z.ZodString) {\n    let stringSchema: z.ZodTypeAny = result;\n    if (validation.email) {\n      stringSchema = (stringSchema as z.ZodString).email(\n        \"Enter a valid email address.\"\n      );\n    }\n    if (validation.minLength !== undefined) {\n      stringSchema = (stringSchema as z.ZodString).min(\n        validation.minLength,\n        `Must be at least ${validation.minLength} characters.`\n      );\n    }\n    if (validation.maxLength !== undefined) {\n      stringSchema = (stringSchema as z.ZodString).max(\n        validation.maxLength,\n        `Must be at most ${validation.maxLength} characters.`\n      );\n    }\n    if (validation.pattern) {\n      try {\n        const regex = new RegExp(validation.pattern);\n        stringSchema = (stringSchema as z.ZodString).regex(\n          regex,\n          validation.custom || \"Invalid format.\"\n        );\n      } catch {\n        // Invalid regex pattern, skip\n        console.warn(\"Invalid regex pattern:\", validation.pattern);\n      }\n    }\n    if (!validation.required) {\n      stringSchema = stringSchema.optional();\n    }\n    result = stringSchema;\n  }\n\n  // Number validations\n  if (result instanceof z.ZodNumber) {\n    let numberSchema: z.ZodTypeAny = result;\n    if (validation.min !== undefined) {\n      numberSchema = (numberSchema as z.ZodNumber).min(\n        validation.min,\n        `Must be at least ${validation.min}.`\n      );\n    }\n    if (validation.max !== undefined) {\n      numberSchema = (numberSchema as z.ZodNumber).max(\n        validation.max,\n        `Must be at most ${validation.max}.`\n      );\n    }\n    if (!validation.required) {\n      numberSchema = numberSchema.optional();\n    }\n    result = numberSchema;\n  }\n\n  // Array validations\n  if (result instanceof z.ZodArray) {\n    let arraySchema: z.ZodTypeAny = result;\n    if (validation.minLength !== undefined) {\n      arraySchema = (arraySchema as z.ZodArray<any>).min(\n        validation.minLength,\n        `Select at least ${validation.minLength} option${\n          validation.minLength !== 1 ? \"s\" : \"\"\n        }.`\n      );\n    }\n    if (validation.maxLength !== undefined) {\n      arraySchema = (arraySchema as z.ZodArray<any>).max(\n        validation.maxLength,\n        `Select at most ${validation.maxLength} option${\n          validation.maxLength !== 1 ? \"s\" : \"\"\n        }.`\n      );\n    }\n    if (!validation.required) {\n      arraySchema = arraySchema.optional();\n    }\n    result = arraySchema;\n  }\n\n  // Boolean validations\n  if (result instanceof z.ZodBoolean) {\n    let booleanSchema: z.ZodTypeAny = result;\n    if (validation.required) {\n      booleanSchema = (booleanSchema as z.ZodBoolean).refine(\n        (val) => val === true,\n        {\n          message: validation.custom || \"This field is required.\",\n        }\n      );\n    } else {\n      booleanSchema = booleanSchema.optional();\n    }\n    result = booleanSchema;\n  }\n\n  return result;\n}\n\n/**\n * Generates a complete Zod schema for the entire form\n */\nexport function generateFormSchema(\n  formConfig: FormConfig\n): z.ZodObject<Record<string, z.ZodTypeAny>> {\n  const shape: Record<string, z.ZodTypeAny> = {};\n\n  formConfig.fields.forEach((field) => {\n    shape[field.name] = generateFieldSchema(field);\n  });\n\n  return z.object(shape);\n}\n\n/**\n * Extracts default values from the form configuration\n */\nexport function getDefaultValues(\n  formConfig: FormConfig\n): Record<string, unknown> {\n  const defaults: Record<string, unknown> = {};\n\n  formConfig.fields.forEach((field) => {\n    if (field.defaultValue !== undefined) {\n      defaults[field.name] = field.defaultValue;\n    } else {\n      // Provide sensible defaults based on type\n      switch (field.type) {\n        case \"text\":\n        case \"email\":\n        case \"textarea\":\n        case \"select\":\n        case \"radio\":\n          defaults[field.name] = \"\";\n          break;\n        case \"number\":\n          defaults[field.name] = field.defaultValue !== undefined ? field.defaultValue : 0;\n          break;\n        case \"slider\":\n          defaults[field.name] = 0;\n          break;\n        case \"checkbox\":\n        case \"yes-no\":\n        case \"switch\":\n          defaults[field.name] = false;\n          break;\n        case \"checkbox-group\":\n          defaults[field.name] = [];\n          break;\n      }\n    }\n  });\n\n  return defaults;\n}\n\n/**\n * Validates a form configuration to ensure it's valid\n */\nexport function validateFormConfig(config: unknown): config is FormConfig {\n  if (!config || typeof config !== \"object\") return false;\n\n  const obj = config as Record<string, unknown>;\n  if (!obj.id || !obj.title || !Array.isArray(obj.fields)) return false;\n\n  // Validate each field\n  for (const field of obj.fields) {\n    if (!field || typeof field !== \"object\") return false;\n    const fieldObj = field as Record<string, unknown>;\n    if (!fieldObj.id || !fieldObj.type || !fieldObj.name || !fieldObj.label)\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Downloads form configuration as JSON file\n */\nexport function downloadFormConfig(formConfig: FormConfig): void {\n  const json = JSON.stringify(formConfig, null, 2);\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement(\"a\");\n  link.href = url;\n  link.download = `${formConfig.id}.json`;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}\n\n/**\n * Parses and validates imported form configuration\n */\nexport function parseFormConfig(jsonString: string): FormConfig | null {\n  try {\n    const config = JSON.parse(jsonString);\n    if (validateFormConfig(config)) {\n      return config;\n    }\n    return null;\n  } catch (e) {\n    console.error(\"Failed to parse form config:\", e);\n    return null;\n  }\n}\n\n/**\n * Returns the icon component for a given field type\n */\nexport function getFieldTypeIcon(type: FieldType): LucideIcon {\n  const iconMap: Record<FieldType, LucideIcon> = {\n    text: Type,\n    email: Mail,\n    phone: Phone,\n    number: Hash,\n    textarea: AlignLeft,\n    select: ChevronDownCircle,\n    \"checkbox-group\": CheckSquare,\n    radio: CircleDot,\n    \"yes-no\": CircleDot,\n    checkbox: SquareCheck,\n    switch: ToggleRight,\n    slider: SlidersHorizontal,\n  };\n  return iconMap[type] || Type;\n}\n\n/**\n * Checks if a field type supports options\n */\nexport function hasOptions(type: FieldType): type is \"select\" | \"checkbox-group\" | \"radio\" {\n  return type === \"select\" || type === \"checkbox-group\" || type === \"radio\";\n}\n\n/**\n * Checks if a field type supports placeholder\n */\nexport function supportsPlaceholder(\n  type: FieldType\n): type is \"text\" | \"email\" | \"phone\" | \"number\" | \"textarea\" {\n  return [\"text\", \"email\", \"phone\", \"number\", \"textarea\"].includes(type);\n}\n\n/**\n * Checks if a field type supports required validation\n */\nexport function supportsRequired(\n  type: FieldType\n): type is \"text\" | \"email\" | \"phone\" | \"number\" | \"textarea\" {\n  return [\"text\", \"email\", \"phone\", \"number\", \"textarea\"].includes(type);\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/forms/hooks/use-form-builder.ts",
      "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport { arrayMove } from \"@dnd-kit/sortable\";\nimport { DragEndEvent } from \"@dnd-kit/core\";\nimport { toast } from \"sonner\";\nimport type { FormConfig, FieldType, FieldConfig } from \"../lib/form-config\";\nimport { createDefaultField, createEmptyForm } from \"../lib/form-config\";\nimport { downloadFormConfig, parseFormConfig } from \"../lib/form-utils\";\n\nexport type ViewMode = \"builder\" | \"preview\" | \"json\";\n\nexport function useFormBuilder() {\n  const [formConfig, setFormConfig] = useState<FormConfig>(createEmptyForm());\n  const [selectedFieldId, setSelectedFieldId] = useState<string | null>(null);\n  const [viewMode, setViewMode] = useState<ViewMode>(\"builder\");\n\n  const addField = (type: FieldType) => {\n    const newField = createDefaultField(type, formConfig.fields.length);\n    setFormConfig((prev) => ({ ...prev, fields: [...prev.fields, newField] }));\n    setSelectedFieldId(newField.id);\n    toast.success(\"Field added\", {\n      description: `${type} field added to the form`,\n    });\n  };\n\n  const deleteField = (fieldId: string) => {\n    setFormConfig((prev) => ({\n      ...prev,\n      fields: prev.fields.filter((f) => f.id !== fieldId),\n    }));\n    if (selectedFieldId === fieldId) setSelectedFieldId(null);\n  };\n\n  const duplicateField = (fieldId: string) => {\n    const field = formConfig.fields.find((f) => f.id === fieldId);\n    if (!field) return;\n\n    const newField = {\n      ...field,\n      id: `field_${crypto.randomUUID()}`,\n      name: `${field.name}_copy`,\n      label: `${field.label} (Copy)`,\n    };\n\n    setFormConfig((prev) => {\n      const index = prev.fields.findIndex((f) => f.id === fieldId);\n      const fields = [...prev.fields];\n      fields.splice(index + 1, 0, newField);\n      return { ...prev, fields };\n    });\n    setSelectedFieldId(newField.id);\n    toast.success(\"Field duplicated\");\n  };\n\n  const updateField = (updatedField: FieldConfig) => {\n    setFormConfig((prev) => ({\n      ...prev,\n      fields: prev.fields.map((f) =>\n        f.id === updatedField.id ? updatedField : f\n      ),\n    }));\n  };\n\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n    if (active.id === over?.id) return;\n\n    setFormConfig((prev) => {\n      const oldIndex = prev.fields.findIndex((f) => f.id === active.id);\n      const newIndex = prev.fields.findIndex((f) => f.id === over?.id);\n      return { ...prev, fields: arrayMove(prev.fields, oldIndex, newIndex) };\n    });\n  };\n\n  const handleExport = () => downloadFormConfig(formConfig);\n\n  const handleImport = () => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json\";\n    input.onchange = (e) => {\n      const file = (e.target as HTMLInputElement).files?.[0];\n      if (!file) return;\n\n      const reader = new FileReader();\n      reader.onload = (event) => {\n        const config = parseFormConfig(event.target?.result as string);\n        if (config) {\n          setFormConfig(config);\n          setSelectedFieldId(null);\n        } else {\n          alert(\"Invalid form configuration file\");\n        }\n      };\n      reader.readAsText(file);\n    };\n    input.click();\n  };\n\n  const updateFormConfig = (updates: Partial<FormConfig>) => {\n    setFormConfig((prev) => ({ ...prev, ...updates }));\n  };\n\n  return {\n    formConfig,\n    selectedFieldId,\n    viewMode,\n    setViewMode,\n    setSelectedFieldId,\n    addField,\n    deleteField,\n    duplicateField,\n    updateField,\n    updateFormConfig,\n    handleDragEnd,\n    handleExport,\n    handleImport,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/forms/components/field-actions.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Settings2, Copy, Trash2 } from \"lucide-react\";\n\ninterface FieldActionsProps {\n  onSettingsClick: (e: React.MouseEvent) => void;\n  onDuplicate?: (e: React.MouseEvent) => void;\n  onDelete: (e: React.MouseEvent) => void;\n}\n\nexport function FieldActions({\n  onSettingsClick,\n  onDuplicate,\n  onDelete,\n}: FieldActionsProps) {\n  return (\n    <div className=\"flex flex-col gap-0.5\">\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={onSettingsClick}\n        title=\"Validation Settings\"\n      >\n        <Settings2 />\n      </Button>\n      {onDuplicate && (\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={onDuplicate}\n          title=\"Duplicate\"\n        >\n          <Copy />\n        </Button>\n      )}\n      <Button variant=\"ghost\" size=\"icon\" onClick={onDelete} title=\"Delete\">\n        <Trash2 />\n      </Button>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/field-editor.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Field, FieldGroup, FieldLabel } from \"@/components/ui/field\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport type { FieldConfig } from \"../lib/form-config\";\n\ninterface FieldEditorProps {\n  field: FieldConfig;\n  onUpdate: (field: FieldConfig) => void;\n  onClose: () => void;\n  open: boolean;\n}\n\nexport function FieldEditor({ field, onUpdate, onClose, open }: FieldEditorProps) {\n  const [localField, setLocalField] = useState(field);\n\n  // Update local field when prop changes\n  useEffect(() => {\n    setLocalField(field);\n  }, [field]);\n\n  const handleUpdate = (updates: Partial<FieldConfig>) => {\n    const updated = { ...localField, ...updates } as FieldConfig;\n    setLocalField(updated);\n    onUpdate(updated);\n  };\n\n  const handleValidationUpdate = (\n    validationUpdates: Partial<NonNullable<FieldConfig[\"validation\"]>>\n  ) => {\n    handleUpdate({\n      validation: {\n        ...localField.validation,\n        ...validationUpdates,\n      },\n    });\n  };\n\n  const supportsMinMax =\n    localField.type === \"number\" || localField.type === \"slider\";\n\n  const supportsLength =\n    localField.type === \"text\" ||\n    localField.type === \"email\" ||\n    localField.type === \"textarea\";\n\n  return (\n    <Dialog open={open} onOpenChange={(open) => !open && onClose()}>\n      <DialogContent>\n        <DialogHeader>\n          <DialogTitle>Validation Settings</DialogTitle>\n        </DialogHeader>\n\n      <FieldGroup className=\"space-y-3\">\n        {supportsLength && (\n          <div className=\"grid grid-cols-2 gap-3\">\n            <Field>\n              <FieldLabel htmlFor=\"field-minlength\" className=\"text-base\">Min Length</FieldLabel>\n              <Input\n                id=\"field-minlength\"\n                type=\"number\"\n                value={localField.validation?.minLength ?? \"\"}\n                onChange={(e) =>\n                  handleValidationUpdate({\n                    minLength: e.target.value\n                      ? parseInt(e.target.value)\n                      : undefined,\n                  })\n                }\n                placeholder=\"None\"\n                min={0}\n                className=\"md:text-base\"\n              />\n            </Field>\n            <Field>\n              <FieldLabel htmlFor=\"field-maxlength\" className=\"text-base\">Max Length</FieldLabel>\n              <Input\n                id=\"field-maxlength\"\n                type=\"number\"\n                value={localField.validation?.maxLength ?? \"\"}\n                onChange={(e) =>\n                  handleValidationUpdate({\n                    maxLength: e.target.value\n                      ? parseInt(e.target.value)\n                      : undefined,\n                  })\n                }\n                placeholder=\"None\"\n                min={0}\n                className=\"md:text-base\"\n              />\n            </Field>\n          </div>\n        )}\n\n        {supportsLength && (\n        <Field>\n          <FieldLabel htmlFor=\"field-pattern\" className=\"text-base\">Regex Pattern</FieldLabel>\n          <Input\n              id=\"field-pattern\"\n              value={localField.validation?.pattern ?? \"\"}\n              onChange={(e) =>\n                handleValidationUpdate({ pattern: e.target.value })\n              }\n              placeholder=\"e.g., ^[A-Za-z]+$\"\n              className=\"font-mono text-base md:text-base\"\n            />\n          </Field>\n        )}\n\n        {supportsMinMax && (\n          <div className=\"grid grid-cols-2 gap-3\">\n            <Field>\n              <FieldLabel htmlFor=\"val-min\" className=\"text-base\">Min Value</FieldLabel>\n              <Input\n                id=\"val-min\"\n                type=\"number\"\n                value={localField.validation?.min ?? \"\"}\n                onChange={(e) =>\n                  handleValidationUpdate({\n                    min: e.target.value\n                      ? parseFloat(e.target.value)\n                      : undefined,\n                  })\n                }\n                placeholder=\"None\"\n                className=\"md:text-base\"\n              />\n            </Field>\n            <Field>\n              <FieldLabel htmlFor=\"val-max\" className=\"text-base\">Max Value</FieldLabel>\n              <Input\n                id=\"val-max\"\n                type=\"number\"\n                value={localField.validation?.max ?? \"\"}\n                onChange={(e) =>\n                  handleValidationUpdate({\n                    max: e.target.value\n                      ? parseFloat(e.target.value)\n                      : undefined,\n                  })\n                }\n                placeholder=\"None\"\n                className=\"md:text-base\"\n              />\n            </Field>\n          </div>\n        )}\n\n        <Field>\n          <FieldLabel htmlFor=\"field-custom-error\" className=\"text-base\">\n            Custom Error Message\n          </FieldLabel>\n          <Textarea\n            id=\"field-custom-error\"\n            value={localField.validation?.custom ?? \"\"}\n            onChange={(e) =>\n              handleValidationUpdate({ custom: e.target.value })\n            }\n            placeholder=\"Message to show when validation fails\"\n            rows={2}\n            className=\"md:text-base\"\n          />\n        </Field>\n      </FieldGroup>\n      </DialogContent>\n    </Dialog>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/field-header.tsx",
      "content": "\"use client\";\n\nimport { FieldConfig, FieldType } from \"../lib/form-config\";\nimport { InlineEdit } from \"@/components/ui/inline-edit\";\nimport {\n  Type,\n  Mail,\n  Phone,\n  Hash,\n  AlignLeft,\n  ChevronDownCircle,\n  CheckSquare,\n  CircleDot,\n  SquareCheck,\n  ToggleRight,\n  SlidersHorizontal,\n  LucideIcon,\n} from \"lucide-react\";\n\ninterface FieldHeaderProps {\n  field: FieldConfig;\n  onLabelUpdate: (value: string) => void;\n  onDescriptionUpdate: (value: string) => void;\n}\n\nconst FIELD_ICON_MAP: Record<FieldType, LucideIcon> = {\n  text: Type,\n  email: Mail,\n  phone: Phone,\n  number: Hash,\n  textarea: AlignLeft,\n  select: ChevronDownCircle,\n  \"checkbox-group\": CheckSquare,\n  radio: CircleDot,\n  \"yes-no\": CircleDot,\n  checkbox: SquareCheck,\n  switch: ToggleRight,\n  slider: SlidersHorizontal,\n};\n\nfunction FieldTypeIcon({\n  type,\n  className,\n}: {\n  type: FieldType;\n  className?: string;\n}) {\n  const Icon = FIELD_ICON_MAP[type] || Type;\n  return <Icon className={className} />;\n}\n\nexport function FieldHeader({\n  field,\n  onLabelUpdate,\n  onDescriptionUpdate,\n}: FieldHeaderProps) {\n  if (field.type === \"checkbox\" || field.type === \"switch\") {\n    return (\n      <div className=\"flex items-center justify-end gap-2\">\n        <div\n          className=\"flex items-center gap-2 text-muted-foreground/60\"\n          title={field.type}\n        >\n          <FieldTypeIcon type={field.type} className=\"h-4 w-4\" />\n          <span className=\"text-[10px] uppercase\">{field.type}</span>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-1\">\n      <div className=\"flex items-center justify-between gap-2\">\n        <InlineEdit\n          value={field.label}\n          onSave={onLabelUpdate}\n          className=\"font-medium text-base text-foreground\"\n          placeholder=\"Field Label\"\n        />\n        <div\n          className=\"flex items-center gap-2 text-muted-foreground/60\"\n          title={field.type}\n        >\n          <FieldTypeIcon type={field.type} className=\"h-4 w-4\" />\n          <span className=\"text-[10px] uppercase\">{field.type}</span>\n        </div>\n      </div>\n      <InlineEdit\n        value={field.description || \"\"}\n        onSave={onDescriptionUpdate}\n        className=\"text-muted-foreground\"\n        placeholder=\"Description\"\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/field-preview.tsx",
      "content": "\"use client\";\n\nimport { FieldConfig, SelectFieldConfig, CheckboxGroupFieldConfig, RadioFieldConfig, SliderFieldConfig } from \"../lib/form-config\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport { Button } from \"@/components/ui/button\";\nimport { InlineEdit } from \"@/components/ui/inline-edit\";\nimport { Plus, X } from \"lucide-react\";\nimport { OptionList } from \"./option-list\";\n\ninterface FieldPreviewProps {\n  field: FieldConfig;\n  onOptionUpdate: (index: number, value: string) => void;\n  onAddOption: () => void;\n  onRemoveOption: (index: number) => void;\n  onLabelUpdate: (value: string) => void;\n}\n\nexport function FieldPreview({\n  field,\n  onOptionUpdate,\n  onAddOption,\n  onRemoveOption,\n  onLabelUpdate,\n}: FieldPreviewProps) {\n  switch (field.type) {\n    case \"text\":\n    case \"email\":\n    case \"phone\":\n    case \"number\":\n      return (\n        <Input\n          disabled\n          type={field.type === \"phone\" ? \"tel\" : field.type}\n          className=\"cursor-pointer bg-muted/20\"\n        />\n      );\n\n    case \"textarea\":\n      return (\n        <Textarea\n          disabled\n          className=\"cursor-pointer bg-muted/20\"\n          rows={field.rows}\n        />\n      );\n\n    case \"select\": {\n      const selectField = field as SelectFieldConfig;\n      return (\n        <OptionList\n          options={selectField.options}\n          fieldId={selectField.id}\n          onOptionUpdate={onOptionUpdate}\n          onAddOption={onAddOption}\n          onRemoveOption={onRemoveOption}\n        />\n      );\n    }\n\n    case \"checkbox-group\": {\n      const checkboxGroupField = field as CheckboxGroupFieldConfig;\n      return (\n        <div className=\"space-y-2\">\n          {checkboxGroupField.options.map((opt, idx) => (\n            <div key={idx} className=\"flex items-center gap-2 group/option\">\n              <Checkbox disabled id={`${field.id}-${idx}`} />\n              <InlineEdit\n                value={opt.label}\n                onSave={(val) => onOptionUpdate(idx, val)}\n                className=\"flex-1 text-base\"\n              />\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-6 w-6 opacity-0 group-hover/option:opacity-100 text-muted-foreground hover:text-destructive\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onRemoveOption(idx);\n                }}\n              >\n                <X className=\"h-3 w-3\" />\n              </Button>\n            </div>\n          ))}\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={(e) => {\n              e.stopPropagation();\n              onAddOption();\n            }}\n            className=\"h-7 text-xs text-muted-foreground\"\n          >\n            <Plus className=\"h-3 w-3 mr-1\" /> Add Option\n          </Button>\n        </div>\n      );\n    }\n\n    case \"radio\": {\n      const radioField = field as RadioFieldConfig;\n      return (\n        <RadioGroup disabled>\n          <div className=\"space-y-2\">\n            {radioField.options.map((opt, idx) => (\n              <div key={idx} className=\"flex items-center gap-2 group/option\">\n                <RadioGroupItem value={opt.value} id={`${field.id}-${idx}`} />\n                <InlineEdit\n                  value={opt.label}\n                  onSave={(val) => onOptionUpdate(idx, val)}\n                  className=\"flex-1 text-base\"\n                />\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-6 w-6 opacity-0 group-hover/option:opacity-100 text-muted-foreground hover:text-destructive\"\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    onRemoveOption(idx);\n                  }}\n                >\n                  <X className=\"h-3 w-3\" />\n                </Button>\n              </div>\n            ))}\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={(e) => {\n                e.stopPropagation();\n                onAddOption();\n              }}\n              className=\"h-7 text-xs text-muted-foreground\"\n            >\n              <Plus className=\"h-3 w-3 mr-1\" /> Add Option\n            </Button>\n          </div>\n        </RadioGroup>\n      );\n    }\n\n    case \"yes-no\":\n      return (\n        <div className=\"flex gap-2\">\n          <Button variant=\"outline\" disabled className=\"flex-1 py-6\">\n            Yes\n          </Button>\n          <Button variant=\"outline\" disabled className=\"flex-1 py-6\">\n            No\n          </Button>\n        </div>\n      );\n\n    case \"checkbox\":\n      return (\n        <div className=\"flex items-center space-x-2\">\n          <Checkbox disabled id={field.id} />\n          <InlineEdit\n            value={field.label}\n            onSave={onLabelUpdate}\n            placeholder=\"Checkbox label\"\n          />\n        </div>\n      );\n\n    case \"switch\":\n      return (\n        <div className=\"flex items-center justify-between\">\n          <InlineEdit\n            value={field.label}\n            onSave={onLabelUpdate}\n            placeholder=\"Switch label\"\n          />\n          <Switch disabled id={field.id} />\n        </div>\n      );\n\n    case \"slider\": {\n      const sliderField = field as SliderFieldConfig;\n      return (\n        <div className=\"space-y-2\">\n          <Slider\n            disabled\n            min={sliderField.min}\n            max={sliderField.max}\n            step={sliderField.step}\n            defaultValue={[sliderField.defaultValue as number]}\n          />\n          <div className=\"flex justify-between text-xs text-muted-foreground px-1\">\n            <span>{sliderField.min}</span>\n            <span>{sliderField.max}</span>\n          </div>\n        </div>\n      );\n    }\n\n    default:\n      return <div>Unsupported field type</div>;\n  }\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/field-toolbox.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { FIELD_TYPES, CATEGORIES, FieldType } from \"../lib/form-config\";\n\ninterface FieldToolboxProps {\n  onAddField: (type: FieldType) => void;\n}\n\nexport function FieldToolbox({ onAddField }: FieldToolboxProps) {\n  return (\n    <div className=\"overflow-y-auto p-4 space-y-6\">\n      <h2 className=\"sr-only\">Fields</h2>\n      {CATEGORIES.map((category) => (\n        <div key={category.id} className=\"space-y-2\">\n          <h3 className=\"text-xs font-medium text-muted-foreground px-1 uppercase tracking-wider\">\n            {category.label}\n          </h3>\n          <div className=\"grid grid-cols-2 gap-2\">\n            {FIELD_TYPES.filter((f) => f.category === category.id).map(\n              (item) => (\n                <Button\n                  key={item.type}\n                  variant=\"outline\"\n                  className=\"flex flex-col items-center justify-center h-16 w-full gap-1.5 whitespace-normal px-2 py-3 text-xs hover:border-primary hover:text-primary transition-all [&>svg]:shrink-0\"\n                  onClick={() => onAddField(item.type)}\n                >\n                  <item.icon className=\"h-5 w-5\" />\n                  <span className=\"text-[10px] font-medium leading-tight text-center\">\n                    {item.label}\n                  </span>\n                </Button>\n              )\n            )}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/floating-controls.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { SidebarTrigger } from \"@/components/ui/sidebar\";\nimport { Upload, Download, MoreHorizontal } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\ntype ViewMode = \"builder\" | \"preview\" | \"json\";\n\ninterface FloatingControlsProps {\n  viewMode: ViewMode;\n  onViewModeChange: (mode: ViewMode) => void;\n  onImport: () => void;\n  onExport: () => void;\n}\n\nexport function FloatingControls({\n  viewMode,\n  onViewModeChange,\n  onImport,\n  onExport,\n}: FloatingControlsProps) {\n  return (\n    <div className=\"fixed bottom-4 left-1/2 -translate-x-1/2 z-50 flex items-center gap-2\">\n      {viewMode === \"builder\" && (\n        <div className=\"md:hidden\">\n          <SidebarTrigger />\n        </div>\n      )}\n      <div className=\"flex bg-background/95 backdrop-blur-sm border rounded-lg p-1\">\n        {([\"builder\", \"preview\", \"json\"] as const).map((mode) => (\n          <Button\n            key={mode}\n            variant={viewMode === mode ? \"default\" : \"ghost\"}\n            size=\"sm\"\n            onClick={() => onViewModeChange(mode)}\n            className={cn(\"capitalize\", mode === \"json\" && \"uppercase\")}\n          >\n            {mode}\n          </Button>\n        ))}\n      </div>\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button variant=\"outline\" size=\"icon\">\n            <MoreHorizontal />\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"center\">\n          <DropdownMenuItem onClick={onImport}>\n            <Upload className=\"mr-2 h-4 w-4\" />\n            Import JSON\n          </DropdownMenuItem>\n          <DropdownMenuItem onClick={onExport}>\n            <Download className=\"mr-2 h-4 w-4\" />\n            Export JSON\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/option-list.tsx",
      "content": "\"use client\";\n\nimport { FieldOption } from \"../lib/form-config\";\nimport { Button } from \"@/components/ui/button\";\nimport { InlineEdit } from \"@/components/ui/inline-edit\";\nimport { Plus, X } from \"lucide-react\";\n\ninterface OptionListProps {\n  options: FieldOption[];\n  fieldId: string;\n  onOptionUpdate: (index: number, value: string) => void;\n  onAddOption: () => void;\n  onRemoveOption: (index: number) => void;\n}\n\nexport function OptionList({\n  options,\n  fieldId,\n  onOptionUpdate,\n  onAddOption,\n  onRemoveOption,\n}: OptionListProps) {\n  return (\n    <div className=\"space-y-2\">\n      {options.map((opt, idx) => (\n        <div key={idx} className=\"flex items-center gap-2 group/option\">\n          <span className=\"text-sm text-muted-foreground w-4 text-center\">\n            {idx + 1}.\n          </span>\n          <InlineEdit\n            value={opt.label}\n            onSave={(val) => onOptionUpdate(idx, val)}\n            className=\"flex-1 text-base\"\n          />\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"h-6 w-6 opacity-0 group-hover/option:opacity-100 text-muted-foreground hover:text-destructive\"\n            onClick={(e) => {\n              e.stopPropagation();\n              onRemoveOption(idx);\n            }}\n          >\n            <X className=\"h-3 w-3\" />\n          </Button>\n        </div>\n      ))}\n      <Button\n        variant=\"ghost\"\n        size=\"sm\"\n        onClick={(e) => {\n          e.stopPropagation();\n          onAddOption();\n        }}\n        className=\"h-7 text-xs text-muted-foreground\"\n      >\n        <Plus className=\"h-3 w-3 mr-1\" /> Add Option\n      </Button>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/components/sortable-field.tsx",
      "content": "\"use client\";\n\nimport { GripVertical } from \"lucide-react\";\nimport { FieldActions } from \"./field-actions\";\nimport { FieldPreview } from \"./field-preview\";\nimport { FieldEditor } from \"./field-editor\";\nimport { FieldHeader } from \"./field-header\";\nimport { InlineEdit } from \"@/components/ui/inline-edit\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Label } from \"@/components/ui/label\";\nimport { Button } from \"@/components/ui/button\";\nimport { CSS } from \"@dnd-kit/utilities\";\n\nimport { useSortable } from \"@dnd-kit/sortable\";\nimport { useState } from \"react\";\n\nimport {\n  FieldConfig,\n  SelectFieldConfig,\n  CheckboxGroupFieldConfig,\n  RadioFieldConfig,\n} from \"../lib/form-config\";\nimport {\n  supportsPlaceholder,\n  supportsRequired,\n  hasOptions,\n} from \"../lib/form-utils\";\n\ninterface SortableFieldProps {\n  field: FieldConfig;\n  isSelected: boolean;\n  onSelect: () => void;\n  onDelete: (e: React.MouseEvent) => void;\n  onDuplicate?: (e: React.MouseEvent) => void;\n  onUpdate: (field: FieldConfig) => void;\n}\n\nexport function SortableField({\n  field,\n  onSelect,\n  onDelete,\n  onDuplicate,\n  onUpdate,\n}: SortableFieldProps) {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id: field.id });\n\n  const [isEditing, setIsEditing] = useState(false);\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n  };\n\n  const handleOptionUpdate = (index: number, val: string) => {\n    if (hasOptions(field.type)) {\n      const fieldWithOptions = field as\n        | SelectFieldConfig\n        | CheckboxGroupFieldConfig\n        | RadioFieldConfig;\n      const newOptions = [...fieldWithOptions.options];\n      newOptions[index] = { ...newOptions[index], label: val, value: val };\n      onUpdate({ ...fieldWithOptions, options: newOptions });\n    }\n  };\n\n  const handleAddOption = () => {\n    if (hasOptions(field.type)) {\n      const fieldWithOptions = field as\n        | SelectFieldConfig\n        | CheckboxGroupFieldConfig\n        | RadioFieldConfig;\n      const newOptions = [\n        ...fieldWithOptions.options,\n        {\n          label: `Option ${fieldWithOptions.options.length + 1}`,\n          value: `option${fieldWithOptions.options.length + 1}`,\n        },\n      ];\n      onUpdate({ ...fieldWithOptions, options: newOptions });\n    }\n  };\n\n  const handleRemoveOption = (index: number) => {\n    if (hasOptions(field.type)) {\n      const fieldWithOptions = field as\n        | SelectFieldConfig\n        | CheckboxGroupFieldConfig\n        | RadioFieldConfig;\n      if (fieldWithOptions.options.length > 1) {\n        const newOptions = fieldWithOptions.options.filter(\n          (_, i: number) => i !== index\n        );\n        onUpdate({ ...fieldWithOptions, options: newOptions });\n      }\n    }\n  };\n\n  const handleLabelUpdate = (val: string) => {\n    onUpdate({ ...field, label: val });\n  };\n\n  const handleDescriptionUpdate = (val: string) => {\n    onUpdate({ ...field, description: val });\n  };\n\n  const handlePlaceholderUpdate = (val: string) => {\n    onUpdate({ ...field, placeholder: val });\n  };\n\n  if (isDragging) {\n    return (\n      <div\n        ref={setNodeRef}\n        style={style}\n        className=\"opacity-50 h-24 border-2 border-dashed border-primary/50 rounded-md bg-muted/50\"\n      />\n    );\n  }\n\n  return (\n    <section>\n      <div className=\"grid grid-cols-[1fr_auto] items-start gap-3\">\n        {/* Field Box */}\n        <div\n          ref={setNodeRef}\n          style={style}\n          onClick={() => onSelect()}\n          className=\"relative group flex items-start gap-3 p-4 flex-1 border bg-muted/10 rounded h-full\"\n        >\n          {/* Content */}\n          <div className=\"flex-1 space-y-3\">\n            <FieldHeader\n              field={field}\n              onLabelUpdate={handleLabelUpdate}\n              onDescriptionUpdate={handleDescriptionUpdate}\n            />\n\n            {/* Render Preview */}\n            <div className=\"relative\">\n              <FieldPreview\n                field={field}\n                onOptionUpdate={handleOptionUpdate}\n                onAddOption={handleAddOption}\n                onRemoveOption={handleRemoveOption}\n                onLabelUpdate={handleLabelUpdate}\n              />\n\n              {/* Inline Placeholder Edit */}\n              {supportsPlaceholder(field.type) && (\n                <div\n                  className={`absolute left-3 pointer-events-none ${\n                    field.type === \"textarea\"\n                      ? \"top-2\"\n                      : \"top-0 h-9 flex items-center\"\n                  }`}\n                >\n                  <div className=\"pointer-events-auto\">\n                    <InlineEdit\n                      value={field.placeholder || \"\"}\n                      onSave={handlePlaceholderUpdate}\n                      className=\"text-muted-foreground font-normal\"\n                      placeholder=\"Placeholder\"\n                    />\n                  </div>\n                </div>\n              )}\n            </div>\n\n            {/* Required Checkbox */}\n            {supportsRequired(field.type) && (\n              <div\n                className=\"flex items-center gap-1.5\"\n                onClick={(e) => e.stopPropagation()}\n              >\n                <Checkbox\n                  id={`${field.id}-required`}\n                  checked={field.validation?.required ?? false}\n                  onCheckedChange={(checked) =>\n                    onUpdate({\n                      ...field,\n                      validation: {\n                        ...field.validation,\n                        required: checked === true,\n                      },\n                    })\n                  }\n                />\n                <Label\n                  htmlFor={`${field.id}-required`}\n                  className=\"text-[10px] font-normal cursor-pointer\"\n                >\n                  Required\n                </Label>\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Actions Column */}\n        <div className=\"flex flex-col gap-0.5 p-1 border bg-muted/30 rounded\">\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            {...attributes}\n            {...listeners}\n            className=\"cursor-grab active:cursor-grabbing\"\n            title=\"Drag to reorder\"\n          >\n            <GripVertical />\n          </Button>\n\n          <FieldActions\n            onSettingsClick={(e) => {\n              e.stopPropagation();\n              setIsEditing(true);\n            }}\n            onDuplicate={onDuplicate}\n            onDelete={onDelete}\n          />\n        </div>\n      </div>\n\n      {/* Validation Settings Dialog */}\n      <FieldEditor\n        field={field}\n        onUpdate={onUpdate}\n        onClose={() => setIsEditing(false)}\n        open={isEditing}\n      />\n    </section>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/form-builder.tsx",
      "content": "\"use client\";\n\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport {\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  SidebarProvider,\n  Sidebar,\n  SidebarInset,\n} from \"@/components/ui/sidebar\";\nimport { MousePointerClick } from \"lucide-react\";\nimport { toast } from \"sonner\";\nimport { useFormBuilder } from \"./hooks/use-form-builder\";\nimport { FormRenderer } from \"./form-renderer\";\nimport { SortableField } from \"./components/sortable-field\";\nimport { FloatingControls } from \"./components/floating-controls\";\nimport { FieldToolbox } from \"./components/field-toolbox\";\n\nexport function FormBuilder() {\n  const {\n    formConfig,\n    selectedFieldId,\n    viewMode,\n    setViewMode,\n    setSelectedFieldId,\n    addField,\n    deleteField,\n    duplicateField,\n    updateField,\n    updateFormConfig,\n    handleDragEnd,\n    handleExport,\n    handleImport,\n  } = useFormBuilder();\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, { activationConstraint: { distance: 5 } }),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  return (\n    <div className=\"relative h-full w-full\">\n      <SidebarProvider\n        defaultOpen\n        className=\"h-full min-h-0! **:data-[slot=sidebar-container]:absolute! **:data-[slot=sidebar-container]:h-full! **:data-[slot=sidebar-container]:inset-y-0!\"\n      >\n        <div className=\"flex h-full w-full relative\">\n          <FloatingControls\n            viewMode={viewMode}\n            onViewModeChange={setViewMode}\n            onImport={handleImport}\n            onExport={handleExport}\n          />\n\n          <Sidebar side=\"left\" collapsible=\"offcanvas\">\n            {viewMode === \"builder\" && <FieldToolbox onAddField={addField} />}\n          </Sidebar>\n\n          <SidebarInset className=\"flex-1 overflow-y-auto bg-muted/20 p-4 md:p-8 w-full\">\n            {viewMode === \"builder\" && (\n              <div className=\"mx-auto w-full max-w-4xl min-h-full\">\n                {/* Form Header */}\n                <div className=\"mb-8\">\n                  <input\n                    value={formConfig.title}\n                    onChange={(e) =>\n                      updateFormConfig({ title: e.target.value })\n                    }\n                    placeholder=\"Untitled Form\"\n                    className=\"w-full bg-transparent text-2xl md:text-3xl font-semibold placeholder:text-muted-foreground/50 focus:outline-none border-none p-0 mb-2\"\n                  />\n                  <input\n                    value={formConfig.description || \"\"}\n                    onChange={(e) =>\n                      updateFormConfig({ description: e.target.value })\n                    }\n                    placeholder=\"Add a description...\"\n                    className=\"w-full bg-transparent text-muted-foreground placeholder:text-muted-foreground/50 focus:outline-none border-none p-0\"\n                  />\n                </div>\n\n                {/* Fields */}\n                {formConfig.fields.length === 0 ? (\n                  <div className=\"flex flex-col items-center justify-center p-12 border border-dashed rounded-lg bg-muted/10\">\n                    <MousePointerClick className=\"h-10 w-10 text-muted-foreground/50 mb-4\" />\n                    <p className=\"text-muted-foreground font-medium mb-1\">\n                      No fields yet\n                    </p>\n                    <p className=\"text-sm text-muted-foreground/70\">\n                      Click a field type in the sidebar to add it\n                    </p>\n                  </div>\n                ) : (\n                  <DndContext\n                    sensors={sensors}\n                    collisionDetection={closestCenter}\n                    onDragEnd={handleDragEnd}\n                  >\n                    <SortableContext\n                      items={formConfig.fields.map((f) => f.id)}\n                      strategy={verticalListSortingStrategy}\n                    >\n                      <div className=\"space-y-4 pb-20\">\n                        {formConfig.fields.map((field) => (\n                          <SortableField\n                            key={field.id}\n                            field={field}\n                            isSelected={selectedFieldId === field.id}\n                            onSelect={() => setSelectedFieldId(field.id)}\n                            onDelete={() => deleteField(field.id)}\n                            onDuplicate={() => duplicateField(field.id)}\n                            onUpdate={updateField}\n                          />\n                        ))}\n                      </div>\n                    </SortableContext>\n                  </DndContext>\n                )}\n              </div>\n            )}\n\n            {viewMode === \"preview\" && (\n              <div className=\"mx-auto w-full max-w-2xl\">\n                <FormRenderer config={formConfig} />\n              </div>\n            )}\n\n            {viewMode === \"json\" && (\n              <div className=\"mx-auto w-full max-w-4xl space-y-6\">\n                <div className=\"rounded-lg border bg-muted/30 p-6\">\n                  <pre className=\"text-sm overflow-x-auto leading-relaxed font-mono\">\n                    {JSON.stringify(formConfig, null, 2)}\n                  </pre>\n                </div>\n                <Button\n                  onClick={() => {\n                    navigator.clipboard.writeText(\n                      JSON.stringify(formConfig, null, 2)\n                    );\n                    toast.success(\"Copied to clipboard\");\n                  }}\n                  variant=\"outline\"\n                >\n                  Copy to Clipboard\n                </Button>\n              </div>\n            )}\n          </SidebarInset>\n        </div>\n      </SidebarProvider>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/form-renderer.tsx",
      "content": "\"use client\";\n\nimport { useForm } from \"@tanstack/react-form\";\nimport { toast } from \"sonner\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Slider } from \"@/components/ui/slider\";\nimport {\n  Field,\n  FieldContent,\n  FieldDescription,\n  FieldError,\n  FieldGroup,\n  FieldLabel,\n  FieldSet,\n  FieldLegend,\n} from \"@/components/ui/field\";\nimport type { FormConfig, FieldConfig } from \"./lib/form-config\";\nimport { generateFormSchema, getDefaultValues } from \"./lib/form-utils\";\nimport { InlineEdit } from \"@/components/ui/inline-edit\";\n\ninterface FormRendererProps {\n  config: FormConfig;\n  onSubmit?: (values: Record<string, unknown>) => void;\n  showSubmitButton?: boolean;\n  onFieldUpdate?: (field: FieldConfig) => void;\n}\n\nexport function FormRenderer({\n  config,\n  onSubmit,\n  showSubmitButton = true,\n  onFieldUpdate,\n}: FormRendererProps) {\n  const formSchema = generateFormSchema(config);\n  const defaultValues = getDefaultValues(config);\n\n  const form = useForm({\n    defaultValues,\n    validators: {\n      onSubmit: formSchema,\n    },\n    onSubmit: async ({ value }) => {\n      if (onSubmit) {\n        onSubmit(value);\n      } else {\n        toast.success(\"Form submitted successfully!\", {\n          description: JSON.stringify(value, null, 2),\n        });\n      }\n    },\n  });\n\n  const formatPhoneNumber = (value: string): string => {\n    if (!value) return \"\";\n\n    // Check if it's an international number (starts with +)\n    const hasPlus = value.startsWith(\"+\");\n\n    // Extract digits and preserve the + if present\n    const digits = value.replace(/\\D/g, \"\");\n    const plus = hasPlus ? \"+\" : \"\";\n\n    // If international (has + or more than 10 digits), format more flexibly\n    if (hasPlus || digits.length > 10) {\n      if (digits.length === 0) return plus;\n      // Group digits in chunks for international format\n      if (digits.length <= 3) return `${plus}${digits}`;\n      if (digits.length <= 6)\n        return `${plus}${digits.slice(0, 3)} ${digits.slice(3)}`;\n      if (digits.length <= 9)\n        return `${plus}${digits.slice(0, 3)} ${digits.slice(\n          3,\n          6\n        )} ${digits.slice(6)}`;\n      // For longer numbers, add spaces every 3-4 digits\n      let formatted = `${plus}${digits.slice(0, 3)} ${digits.slice(\n        3,\n        6\n      )} ${digits.slice(6, 9)}`;\n      if (digits.length > 9) {\n        formatted += ` ${digits.slice(9)}`;\n      }\n      return formatted;\n    }\n\n    // US format: (XXX) XXX-XXXX\n    if (digits.length === 0) return \"\";\n    // Handle US numbers that might start with 1\n    const usDigits =\n      digits.length === 11 && digits[0] === \"1\" ? digits.slice(1) : digits;\n    if (usDigits.length <= 3) return `(${usDigits}`;\n    if (usDigits.length <= 6)\n      return `(${usDigits.slice(0, 3)}) ${usDigits.slice(3)}`;\n    return `(${usDigits.slice(0, 3)}) ${usDigits.slice(3, 6)}-${usDigits.slice(\n      6,\n      10\n    )}`;\n  };\n\n  const renderField = (fieldConfig: FieldConfig) => {\n    switch (fieldConfig.type) {\n      case \"text\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel\n                    htmlFor={onFieldUpdate ? undefined : field.name}\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLabel>\n                  <Input\n                    id={field.name}\n                    name={field.name}\n                    type={fieldConfig.type}\n                    value={field.state.value as string}\n                    onBlur={field.handleBlur}\n                    onChange={(e) => field.handleChange(e.target.value)}\n                    aria-invalid={isInvalid}\n                    placeholder={fieldConfig.placeholder}\n                    autoComplete=\"off\"\n                  />\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"email\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel\n                    htmlFor={onFieldUpdate ? undefined : field.name}\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLabel>\n                  <Input\n                    id={field.name}\n                    name={field.name}\n                    type=\"email\"\n                    value={field.state.value as string}\n                    onBlur={field.handleBlur}\n                    onChange={(e) => {\n                      // Remove spaces from email input\n                      const valueWithoutSpaces = e.target.value.replace(\n                        /\\s/g,\n                        \"\"\n                      );\n                      field.handleChange(valueWithoutSpaces);\n                    }}\n                    aria-invalid={isInvalid}\n                    placeholder={fieldConfig.placeholder}\n                    autoComplete=\"email\"\n                  />\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"phone\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel\n                    htmlFor={onFieldUpdate ? undefined : field.name}\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLabel>\n                  <Input\n                    id={field.name}\n                    name={field.name}\n                    type=\"tel\"\n                    value={formatPhoneNumber(field.state.value as string)}\n                    onBlur={field.handleBlur}\n                    onChange={(e) => {\n                      const input = e.target.value;\n                      // Preserve + for international numbers\n                      const hasPlus = input.startsWith(\"+\");\n                      const formatted = formatPhoneNumber(input);\n                      // Store digits with + prefix if it was international\n                      const digits = formatted.replace(/\\D/g, \"\");\n                      const storedValue =\n                        hasPlus && digits.length > 0 ? `+${digits}` : digits;\n                      field.handleChange(storedValue);\n                    }}\n                    aria-invalid={isInvalid}\n                    placeholder={fieldConfig.placeholder}\n                    autoComplete=\"tel\"\n                  />\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"number\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel\n                    htmlFor={onFieldUpdate ? undefined : field.name}\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLabel>\n                  <Input\n                    id={field.name}\n                    name={field.name}\n                    type=\"number\"\n                    value={field.state.value as number}\n                    onBlur={field.handleBlur}\n                    onChange={(e) =>\n                      field.handleChange(parseFloat(e.target.value) || 0)\n                    }\n                    aria-invalid={isInvalid}\n                    placeholder={fieldConfig.placeholder}\n                  />\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"textarea\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel\n                    htmlFor={onFieldUpdate ? undefined : field.name}\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLabel>\n                  <Textarea\n                    id={field.name}\n                    name={field.name}\n                    value={field.state.value as string}\n                    onBlur={field.handleBlur}\n                    onChange={(e) => field.handleChange(e.target.value)}\n                    aria-invalid={isInvalid}\n                    placeholder={fieldConfig.placeholder}\n                    rows={fieldConfig.rows}\n                  />\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"select\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel\n                    htmlFor={onFieldUpdate ? undefined : field.name}\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLabel>\n                  <Select\n                    name={field.name}\n                    value={field.state.value as string}\n                    onValueChange={field.handleChange}\n                  >\n                    <SelectTrigger id={field.name} aria-invalid={isInvalid}>\n                      <SelectValue\n                        placeholder={\n                          fieldConfig.placeholder || \"Select an option\"\n                        }\n                      />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {fieldConfig.options.map((option) => (\n                        <SelectItem key={option.value} value={option.value}>\n                          {option.label}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"checkbox-group\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            mode=\"array\"\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <FieldSet>\n                  <FieldLegend\n                    variant=\"label\"\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLegend>\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  <FieldGroup data-slot=\"checkbox-group\">\n                    {fieldConfig.options.map((option) => (\n                      <FieldLabel\n                        key={option.value}\n                        htmlFor={`${field.name}-${option.value}`}\n                      >\n                        <Field\n                          orientation=\"horizontal\"\n                          data-invalid={isInvalid}\n                        >\n                          <FieldContent>\n                            <span className=\"text-sm\">{option.label}</span>\n                          </FieldContent>\n                          <Checkbox\n                            id={`${field.name}-${option.value}`}\n                            name={field.name}\n                            aria-invalid={isInvalid}\n                            checked={(field.state.value as string[]).includes(\n                              option.value\n                            )}\n                            onCheckedChange={(checked) => {\n                              if (checked) {\n                                field.pushValue(option.value as never);\n                              } else {\n                                const index = (\n                                  field.state.value as string[]\n                                ).indexOf(option.value);\n                                if (index > -1) {\n                                  field.removeValue(index);\n                                }\n                              }\n                            }}\n                          />\n                        </Field>\n                      </FieldLabel>\n                    ))}\n                  </FieldGroup>\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </FieldSet>\n              );\n            }}\n          />\n        );\n\n      case \"radio\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <FieldSet>\n                  <FieldLegend\n                    variant=\"label\"\n                    onClick={(e) => {\n                      if (onFieldUpdate) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }\n                    }}\n                  >\n                    {onFieldUpdate ? (\n                      <InlineEdit\n                        value={fieldConfig.label}\n                        onSave={(val) =>\n                          onFieldUpdate({ ...fieldConfig, label: val })\n                        }\n                        className=\"font-medium\"\n                        placeholder=\"Field Label\"\n                      />\n                    ) : (\n                      fieldConfig.label\n                    )}\n                  </FieldLegend>\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  <RadioGroup\n                    name={field.name}\n                    value={field.state.value as string}\n                    onValueChange={field.handleChange}\n                  >\n                    {fieldConfig.options.map((option) => (\n                      <FieldLabel\n                        key={option.value}\n                        htmlFor={`${field.name}-${option.value}`}\n                      >\n                        <Field\n                          orientation=\"horizontal\"\n                          data-invalid={isInvalid}\n                        >\n                          <FieldContent>\n                            <span className=\"text-sm\">{option.label}</span>\n                          </FieldContent>\n                          <RadioGroupItem\n                            value={option.value}\n                            id={`${field.name}-${option.value}`}\n                            aria-invalid={isInvalid}\n                          />\n                        </Field>\n                      </FieldLabel>\n                    ))}\n                  </RadioGroup>\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </FieldSet>\n              );\n            }}\n          />\n        );\n\n      case \"yes-no\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              const value = field.state.value as boolean | undefined;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <FieldLabel>{fieldConfig.label}</FieldLabel>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      type=\"button\"\n                      variant={value === true ? \"default\" : \"outline\"}\n                      onClick={() => field.handleChange(true)}\n                      className={cn(\n                        \"flex-1 py-6\",\n                        value === true && \"border border-transparent\"\n                      )}\n                    >\n                      Yes\n                    </Button>\n                    <Button\n                      type=\"button\"\n                      variant={value === false ? \"default\" : \"outline\"}\n                      onClick={() => field.handleChange(false)}\n                      className={cn(\n                        \"flex-1 py-6\",\n                        value === false && \"border border-transparent\"\n                      )}\n                    >\n                      No\n                    </Button>\n                  </div>\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"checkbox\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field orientation=\"horizontal\" data-invalid={isInvalid}>\n                  <Checkbox\n                    id={field.name}\n                    name={field.name}\n                    checked={field.state.value as boolean}\n                    onCheckedChange={field.handleChange}\n                    aria-invalid={isInvalid}\n                  />\n                  <FieldContent>\n                    <FieldLabel htmlFor={field.name}>\n                      {fieldConfig.label}\n                    </FieldLabel>\n                    {fieldConfig.description && (\n                      <FieldDescription>\n                        {fieldConfig.description}\n                      </FieldDescription>\n                    )}\n                  </FieldContent>\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"switch\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              return (\n                <Field orientation=\"horizontal\" data-invalid={isInvalid}>\n                  <FieldContent>\n                    <FieldLabel htmlFor={field.name}>\n                      {fieldConfig.label}\n                    </FieldLabel>\n                    {fieldConfig.description && (\n                      <FieldDescription>\n                        {fieldConfig.description}\n                      </FieldDescription>\n                    )}\n                    {isInvalid && (\n                      <FieldError errors={field.state.meta.errors} />\n                    )}\n                  </FieldContent>\n                  <Switch\n                    id={field.name}\n                    name={field.name}\n                    checked={field.state.value as boolean}\n                    onCheckedChange={field.handleChange}\n                    aria-invalid={isInvalid}\n                  />\n                </Field>\n              );\n            }}\n          />\n        );\n\n      case \"slider\":\n        return (\n          <form.Field\n            key={fieldConfig.id}\n            name={fieldConfig.name}\n            // eslint-disable-next-line react/no-children-prop\n            children={(field) => {\n              const isInvalid =\n                field.state.meta.isTouched && !field.state.meta.isValid;\n              const currentValue = field.state.value as number;\n              return (\n                <Field data-invalid={isInvalid}>\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <FieldLabel\n                      htmlFor={onFieldUpdate ? undefined : field.name}\n                      onClick={(e) => {\n                        if (onFieldUpdate) {\n                          e.preventDefault();\n                          e.stopPropagation();\n                        }\n                      }}\n                    >\n                      {onFieldUpdate ? (\n                        <InlineEdit\n                          value={fieldConfig.label}\n                          onSave={(val) =>\n                            onFieldUpdate({ ...fieldConfig, label: val })\n                          }\n                          className=\"font-medium\"\n                          placeholder=\"Field Label\"\n                        />\n                      ) : (\n                        fieldConfig.label\n                      )}\n                    </FieldLabel>\n                    <span className=\"text-sm font-medium text-muted-foreground\">\n                      {currentValue}\n                    </span>\n                  </div>\n                  <Slider\n                    id={field.name}\n                    name={field.name}\n                    value={[currentValue]}\n                    onValueChange={(values) => field.handleChange(values[0])}\n                    min={fieldConfig.min}\n                    max={fieldConfig.max}\n                    step={fieldConfig.step}\n                    aria-invalid={isInvalid}\n                  />\n                  <div className=\"flex justify-between text-xs text-muted-foreground mt-1\">\n                    <span>{fieldConfig.min ?? 0}</span>\n                    <span>{fieldConfig.max ?? 100}</span>\n                  </div>\n                  {fieldConfig.description && (\n                    <FieldDescription>\n                      {fieldConfig.description}\n                    </FieldDescription>\n                  )}\n                  {isInvalid && <FieldError errors={field.state.meta.errors} />}\n                </Field>\n              );\n            }}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        form.handleSubmit();\n      }}\n      className=\"space-y-6\"\n    >\n      {config.title && (\n        <div className=\"space-y-2\">\n          <h2 className=\"text-2xl font-bold\">{config.title}</h2>\n          {config.description && (\n            <p className=\"text-muted-foreground\">{config.description}</p>\n          )}\n        </div>\n      )}\n\n      <FieldGroup>{config.fields.map(renderField)}</FieldGroup>\n\n      {showSubmitButton && (\n        <div className=\"flex gap-2\">\n          <Button type=\"submit\">Submit</Button>\n          <Button type=\"button\" variant=\"outline\" onClick={() => form.reset()}>\n            Reset\n          </Button>\n        </div>\n      )}\n    </form>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/forms/index.ts",
      "content": "// Main exports for the forms component library\nexport { FormBuilder } from \"./form-builder\";\nexport { FormRenderer } from \"./form-renderer\";\n\n// Export hook\nexport { useFormBuilder } from \"./hooks/use-form-builder\";\nexport type { ViewMode } from \"./hooks/use-form-builder\";\n\n// Export types\nexport type {\n  FormConfig,\n  FieldConfig,\n  FieldType,\n  FieldOption,\n  ValidationRule,\n  TextFieldConfig,\n  NumberFieldConfig,\n  TextareaFieldConfig,\n  SelectFieldConfig,\n  CheckboxGroupFieldConfig,\n  RadioFieldConfig,\n  CheckboxFieldConfig,\n  SwitchFieldConfig,\n  SliderFieldConfig,\n  YesNoFieldConfig,\n  FieldTypeConfig,\n} from \"./lib/form-config\";\n\nexport {\n  createDefaultField,\n  createEmptyForm,\n  FIELD_TYPES,\n  CATEGORIES,\n} from \"./lib/form-config\";\n\n// Export JSON utilities\nexport {\n  downloadFormConfig,\n  parseFormConfig,\n  validateFormConfig,\n  generateFormSchema,\n  getDefaultValues,\n  generateFieldSchema,\n  getFieldTypeIcon,\n  hasOptions,\n  supportsPlaceholder,\n  supportsRequired,\n} from \"./lib/form-utils\";\n",
      "type": "registry:component"
    }
  ]
}